name: critical-action

on:
  workflow_dispatch:
  merge_group:
    types: [checks_requested]

permissions:
  checks: write
  actions: read
  contents: read

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
      with:
        fetch-depth: 0
        token: ${{secrets.TEST_GITHUB_TOKEN}}

    - name: Check for existing workflow runs
      uses: actions/github-script@v7
      id: check_concurrent_runs
      with:
        script: |
          const criticalWorkflowFiles = ['critical-action.yml'];
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const currentRunId = context.runId;
          let concurrentRun = null;

          core.info(`Checking for concurrent runs of workflows: ${criticalWorkflowFiles.join(', ')}`);
          core.info(`Current run ID: ${currentRunId}`);

          try {
            for (const workflowFile of criticalWorkflowFiles) {
              core.info(`Checking workflow: ${workflowFile}`);
              const runs = await github.paginate(github.rest.actions.listWorkflowRuns, {
                owner: owner,
                repo: repo,
                workflow_id: workflowFile,
                status: 'in_progress,queued',
              });

              core.info(`Found ${runs.length} active/queued runs for ${workflowFile}.`);
              for (const run of runs) {
                if (run.id !== currentRunId) {
                  core.warning(`Found concurrent run: ID=${run.id}, Workflow=${workflowFile}, Status=${run.status}, URL=${run.html_url}`);
                  concurrentRun = run;
                  break;
                } else {
                  core.info(` - Run ${run.id} (this run) - Skipping`);
                }
              }
              if (concurrentRun) break;
            }

            if (concurrentRun) {
              core.setFailed(`Aborting workflow because another critical workflow instance (Run ID: ${concurrentRun.id}, Workflow: ${concurrentRun.workflow_id}) is already running or queued. See: ${concurrentRun.html_url}`);
              return;
            }

            core.info('No concurrent critical runs found. Proceeding.');

          } catch (error) {
            core.error(`Error checking for workflow runs: ${error}`);
            core.setFailed(`Failed to check for concurrent workflow runs: ${error.message}`);
          }
      env:
        GITHUB_TOKEN: ${{ secrets.TEST_GITHUB_TOKEN }}

    - name: Create Pending Merge Lock Check
      id: create_merge_lock
      uses: actions/github-script@v7
      with:
        script: |
          const checkName = 'merge-lock-critical-workflow';
          console.log(`Creating pending check run: ${checkName}`);
          try {
            const response = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: checkName,
              head_sha: context.payload.pull_request?.head.sha || context.sha,
              status: 'in_progress',
              output: {
                title: 'Critical Workflow Running',
                summary: 'Merges are temporarily blocked while this critical workflow runs.'
              }
            });
            console.log(`Check run created with ID: ${response.data.id}`);
            return response.data.id
          } catch (error) {
            console.error(`Error creating check run ${checkRunId}: ${error}`);
            core.setFailed(`Failed to set merge lock status check: ${error.message}`);
          }
      env:
        GITHUB_TOKEN: ${{ secrets.TEST_GITHUB_TOKEN }}

    - name: Pause for 60 seconds to allow merge lock check
      run: |
        echo "Workflow paused for 60 seconds."
        echo "Go to a Pull Request targeting the protected branch."
        echo "The 'merge-lock-critical-workflows' status check should be yellow (pending)."
        echo "The merge button should be disabled or indicate the check needs to pass."
        sleep 20
        echo "Resuming workflow..."
      shell: bash

    - name: Update Merge Lock Check to Success
      uses: actions/github-script@v7
      if: always() && steps.create_merge_lock.outputs.result
      with:
        script: |
          const checkName = 'merge-lock-critical-workflow'; // Ensure this matches Create step & Branch Protection
          const checkRunId_raw = '${{ steps.create_merge_lock.outputs.result }}';
          const jobStatus = '${{ job.status }}';
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          core.info(`Update Step: Starting.`);
          core.info(`Update Step: Received raw checkRunId from create step output: '${checkRunId_raw}'`);
          core.info(`Update Step: Current job status: '${jobStatus}'`);
          if (!checkRunId_raw || checkRunId_raw === '' || checkRunId_raw === 'null' || checkRunId_raw === 'undefined') {
            core.error(`Update Step: FAILURE - Check run ID is missing or invalid ('${checkRunId_raw}'). Cannot release lock.`);
            core.setFailed("Update Step: Could not retrieve valid check run ID to release the merge lock."); // FAIL THE STEP
            return;
          }
          let parsedId;
          try {
            parsedId = parseInt(checkRunId_raw, 10);
            if (isNaN(parsedId)) {
              throw new Error(`Parsed checkRunId is NaN.`);
            }
            core.info(`Update Step: Successfully parsed checkRunId: ${parsedId}`);
          } catch (parseError) {
            core.error(`Update Step: FAILURE - Could not parse checkRunId '${checkRunId_raw}' as an integer: ${parseError.message}`);
            core.setFailed(`Update Step: Failed to parse checkRunId '${checkRunId_raw}'.`); // FAIL THE STEP
            return;
          }
          const checkConclusion = 'success';
          const updatePayload = {
            owner: owner,
            repo: repo,
            check_run_id: parsedId,
            status: 'completed',      // Check is finished
            conclusion: checkConclusion, // Release the lock
            output: {
              title: 'Critical Action Finished',
              summary: `Workflow '${context.workflow}' completed job with status: ${jobStatus}. Merge lock released.`
            }
          };
          core.info(`Update Step: Attempting to update check run ID ${parsedId} with conclusion '${checkConclusion}'`);
          try {
            const response = await github.rest.checks.update(updatePayload);
            if (response.status !== 200) {
              throw new Error(`GitHub API returned status ${response.status}, expected 200.`);
            }
            core.info(`Update Step: SUCCESS - Check run (ID: ${parsedId}) updated successfully via API. Merge lock should be released.`);

          } catch (error) {
            core.error(`!!!! Update Step: FAILURE - Caught error during checks.update API call for ID ${parsedId} !!!!`);
            core.error(`Update Step: Error Message: ${error.message}`);
            if (error.status) {
                core.error(`Update Step: HTTP Status Code: ${error.status}`); // Log HTTP status if available from the error object
            }
            if (error.response && error.response.data) {
                core.error(`Update Step: API Response Data: ${JSON.stringify(error.response.data)}`);
            }
            core.setFailed(`Update Step: Failed to release merge lock via checks.update API: ${error.message}`);
          }
      env:
        GITHUB_TOKEN: ${{ secrets.TEST_GITHUB_TOKEN }}
